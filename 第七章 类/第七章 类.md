# 第七章 类



1. 定义在类内部的函数是隐式的inline函数。

2.  C++允许把cinst关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数。

   常量对象，以及常量对象的引用或指针都只能调用常量成员函数。

3.  一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。

4.  类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。

5.  不同于其他成员函数，构造函数不能被声明成const的。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。

6.  只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。

   如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内初始值时，这个类才适合于使用合成的默认构造函数。

7.  构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。

8.  使用class和struct定义类唯一的区别就是默认的访问权限（class为private，struct为public）。

9.  友元：允许其他类或者函数访问它的非公有成员。==friend+函数声明==

   1. 一般来说，最好在类定义开始或结束前的位置集中声明友元。
   2. 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。
   3. 许多编译器并未强制限定友元函数必须在使用之前在类的外部声明，不过最好还是在之前提供一个独立的函数声明。

10.  定义在类内部的成员函数是自动inline的。

    ​		我们可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义。

    ​		不过最好只在类外部定义的地方说明inline，这样更容易理解。inline成员函数也应该与相应的类定义在同一个头文件中。

11.  mutable关键字可以使成员变为==可变数据成员==，一个可变数据成员永远不会是const，即使它是const对象的成员。

    因此，一个const成员函数可以改变一个可变成员的值。

12. **返回*this的成员函数。 **

    <img src="D:\GitHub\CppPrimer5th\第七章 类\pic\pic1.png" style="zoom: 75%;" />

13.  一个类的成员类型不能是该类自己。但是类允许包含指向它自身类型的引用或指针。

    ```cpp
    class Person {
    	string m_name;
    	Person* next;
    	Person* prev;
    };
    ```

14. **类之间的友元关系：**

    如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。

    <img src="D:\GitHub\CppPrimer5th\第七章 类\pic\pic2.png" style="zoom: 62%;" />

    ​		必须要注意的一点是，==友元关系不存在传递性==。也就是说，如果Window_mgr有它自己的友元，则这些友元并不能理所当然地具有访问Screen的特权。

    

    令成员函数作为友元：

    ​		当把一个成员函数声明成友元时，必须明确指出该成员函数属于那个类。

    <img src="D:\GitHub\CppPrimer5th\第七章 类\pic\pic3.png" style="zoom: 62%;" />

    

    函数重载和友元：

    ​		尽管重载函数的名字相同，但它们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明。

    <img src="D:\GitHub\CppPrimer5th\第七章 类\pic\pic4.png" style="zoom: 62%;" />

    

    友元函数和作用域：

    <img src="D:\GitHub\CppPrimer5th\第七章 类\pic\pic5.png" style="zoom: 53%;" />

15.  ==一个类就是一个作用域==的事实能够很好地解释为什么当我们在类的外部定义成员函数时必须同时提供类名和函数名。

16.  ==编译器处理完类中的全部声明后才会处理成员函数的定义。==

17.  如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员赋值。

18.  <img src="D:\GitHub\CppPrimer5th\第七章 类\pic\pic6.png" style="zoom:55%;" />

19.  了解存在委托构造函数这一概念。

20.  在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。

21.  聚合类（略）、字面值常量类（略）

22.  **==类的静态成员==**

    <img src="D:\GitHub\CppPrimer5th\第七章 类\pic\pic7.png" style="zoom:55%;" />

    ​		我们通过在成员的声明之前加上关键字static使得其与类关联在一起。类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。

    ​		通常情况下我们最好在类的外部定义静态成员（只能定义一次），注意在定义时不能重复static关键字，该关键字只出现在类内部的声明语句中。

    ​		一般来说，不能在类的内部初始化静态成员。

23. 构造函数初始化的两种写法： 

    <img src="D:\GitHub\CppPrimer5th\第七章 类\pic\pic8.png" style="zoom: 75%;" />

    <img src="D:\GitHub\CppPrimer5th\第七章 类\pic\pic9.png" style="zoom: 75%;" />

    

    

    ## 习题

1. 练习7.46

<img src="D:\GitHub\CppPrimer5th\第七章 类\pic\pic10.png" style="zoom: 75%;" />



2. 练习7.56

<img src="D:\GitHub\CppPrimer5th\第七章 类\pic\pic11.png" style="zoom:75%;" />