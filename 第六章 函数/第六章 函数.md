# 第六章 函数

1. 函数每个形参的类型都要写出来。即使某个形参不被使用，也必须为它提供一个实参。

2.  static：在定义局部变量时前面加上static可定义为局部静态对象。<br>局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。

3.  函数声明也称作函数原型。函数应该在头文件中声明而在源文件中定义。

4.  如果函数无需改变引用形参的值，**强烈建议**将其声明为常量引用。

   <img src=".\pic\pic1.png" style="zoom: 60%;" />

5.  ```cpp
    int &arr[10];		//将arr声明成引用的数组
    int (&arr)[10];		//arr是具有10个整数的整型数组的引用
    int *matrix[10];		//10个指针构成的数组
    int (*matrix)[10];		//指向含有10个整数的数组的指针
    ```

6. ```cpp
   //主函数
   int main(int argc, char* argv[])
   ```

   第一个形参argc代表数组中字符串的数量。第二个形参argv是一个数组，它的元素是指向C风格字符串的指针，即argv指向char*。

   当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。

7. **在含有return语句的循环后面也应该有一条return语句，如果没有的话该程序就是错误的。很多编译器都无法发现此类错误。**

8.  不要返回局部对象的引用或指针。main函数不能调用它自己。

9.  <br><img src=".\pic\pic2.png" style="zoom: 75%;" />

10.  声明一个返回数组指针的函数：<br><img src=".\pic\pic3.png" style="zoom: 60%;" /><br><br>

使用尾置返回类型
<img src=".\pic\pic4.png" style="zoom:50%;" /><br><br>

使用decltype<img src=".\pic\pic5.png" style="zoom:50%;" />

11.  如果同一作用域内的几个函数名字相同但形参列表不同（形参数量或形参类型不同），我们称之为重载函数。（注意是形参类型不是形参名字）<br>main函数不能重载

12. **重载和const形参**

    <img src=".\pic\pic6.png" style="zoom:55%;" />

13. 在不同的作用域中无法重载函数名。因为如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。<br>在C++语言中，名字查找发生在类型检查之前。

14. 默认实参<br>1.我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。<br>2. 尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。<br>3. 在给定的作用域中，一个形参只能被赋予一次默认实参。使用默认实参的方法只需要在调用函数时省略该实参就可以了。<br>**通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。**


15. 内联函数<br>1. 将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开。内联函数可避免函数调用的开销。<br>2. 在函数的返回类型前面加上关键字inline，就可以将函数声明为内联函数。一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。<br>3. 内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。

16. constexpr函数<br>1.constexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数题中必须有且只有一条return语句。<br>2. constexpr函数不一定返回常量表达式。

17.  内联函数和constexpr函数通常定义在头文件中。

18. assert预处理宏<br>1. assert是一种预处理宏，所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。<br>2. assert宏使用一个表达式作为它的条件：assert（expr）；首先对expr求值，如果表达式为假，assert输出信息并终止程序的运行。如果表达式为真，assert什么也不做。<br>3. assert宏定义在cassert头文件中。和预处理变量一样，宏名字在程序内必须唯一。含有cassert头文件的程序不能再定义名为assert的变量、函数或者其他实体。<br>4. 除了assert之外，现代C++程序很少再使用预处理宏了。

19. NDEBUG预处理变量<br>1. assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。<br>2. 我们可以使用一个#define

20.  函数指针

    ```cpp
    //pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型。
    bool (*pf)(const string& , const string&);
    ```

<img src=".\pic\pic7.png" style="zoom: 67%;" />

<img src=".\pic\pic8.png" style="zoom:55%;" />

21.  牢记当我们将decltype用于某个函数时，它返回函数类型而非指针类型。因此，我们显式地加上*以表明我们需要返回指针，而非函数本身。